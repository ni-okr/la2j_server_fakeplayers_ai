# АРХИТЕКТУРА СИСТЕМЫ БОТОВ L2J

## ОБЩАЯ АРХИТЕКТУРА

### Принципы архитектуры
- **Component-Based**: Модульная архитектура с независимыми компонентами
- **Event-Driven**: Асинхронная обработка событий
- **State Machine**: Четкие состояния и переходы
- **Dependency Injection**: Слабая связанность компонентов
- **SOLID Principles**: Соблюдение принципов объектно-ориентированного программирования

### Диаграмма высокого уровня
```
┌─────────────────────────────────────────────────────────────┐
│                    L2J BOT SYSTEM                          │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Bot       │  │   Bot       │  │   Bot       │   ...   │
│  │  Manager    │  │  Manager    │  │  Manager    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  Behavior   │  │  Behavior   │  │  Behavior   │   ...   │
│  │  Manager    │  │  Manager    │  │  Manager    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Action    │  │   Action    │  │   Action    │   ...   │
│  │  Manager    │  │  Manager    │  │  Manager    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │    AI       │  │   Event     │  │   Config    │        │
│  │   Core      │  │  Manager    │  │  Manager    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   L2J       │  │   MariaDB   │  │   Logging   │        │
│  │  Server     │  │  Database   │  │   System    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

## КОМПОНЕНТЫ СИСТЕМЫ

### 1. CORE COMPONENTS (Ядро системы)

#### 1.1 BotManager
```java
public class BotManager {
    private final Map<Integer, FakePlayer> bots = new ConcurrentHashMap<>();
    private final BotConfig config;
    private final EventManager eventManager;
    
    public FakePlayer createBot(int botId, BotType type);
    public void removeBot(int botId);
    public FakePlayer getBot(int botId);
    public Collection<FakePlayer> getAllBots();
    public int getBotCount();
    public boolean hasBot(int botId);
}
```

**Ответственности:**
- Управление жизненным циклом ботов
- Создание и удаление ботов
- Мониторинг состояния ботов
- Интеграция с L2J сервером

#### 1.2 BotContext
```java
public class BotContext {
    private final int botId;
    private final FakePlayer bot;
    private final BotState currentState;
    private final Map<String, Object> data;
    private final EventManager eventManager;
    
    public BotState getCurrentState();
    public void setState(BotState newState);
    public Object getData(String key);
    public void setData(String key, Object value);
    public void publishEvent(BotEvent event);
}
```

**Ответственности:**
- Хранение состояния бота
- Управление данными бота
- Публикация событий
- Координация между компонентами

#### 1.3 BotState
```java
public enum BotState {
    IDLE,           // Простой
    FARMING,        // Фарм
    QUESTING,       // Квесты
    PVP,            // PvP
    CLAN,           // Клан
    MOVING,         // Движение
    ATTACKING,      // Атака
    HEALING,        // Лечение
    DEAD,           // Мертв
    DISCONNECTED    // Отключен
}
```

**Ответственности:**
- Определение состояний бота
- Валидация переходов между состояниями
- Обработка событий в каждом состоянии

### 2. AI COMPONENTS (ИИ система)

#### 2.1 AICore
```java
public class AICore {
    private final DecisionMaker decisionMaker;
    private final GoalPlanner goalPlanner;
    private final BehaviorSelector behaviorSelector;
    private final ActionPlanner actionPlanner;
    
    public void process(BotContext context);
    public void updateGoals(BotContext context);
    public IBehavior selectBehavior(BotContext context);
    public List<IAction> planActions(BotContext context);
}
```

**Ответственности:**
- Центральная логика ИИ
- Координация между компонентами ИИ
- Обработка контекста бота
- Принятие решений

#### 2.2 DecisionMaker
```java
public class DecisionMaker {
    private final List<IDecisionRule> rules;
    
    public Decision makeDecision(BotContext context);
    public void addRule(IDecisionRule rule);
    public void removeRule(IDecisionRule rule);
}
```

**Ответственности:**
- Принятие решений на основе правил
- Оценка различных вариантов действий
- Выбор оптимального решения
- Обработка конфликтных ситуаций

#### 2.3 GoalPlanner
```java
public class GoalPlanner {
    private final List<IGoal> goals;
    
    public List<IGoal> getActiveGoals(BotContext context);
    public void addGoal(IGoal goal);
    public void removeGoal(IGoal goal);
    public void updateGoals(BotContext context);
}
```

**Ответственности:**
- Планирование целей бота
- Приоритизация целей
- Обновление целей на основе контекста
- Управление жизненным циклом целей

### 3. BEHAVIOR COMPONENTS (Поведения)

#### 3.1 IBehavior Interface
```java
public interface IBehavior {
    boolean canExecute(BotContext context);
    void execute(BotContext context);
    int getPriority();
    BehaviorType getType();
    boolean isActive();
    void activate();
    void deactivate();
}
```

#### 3.2 AbstractBehavior
```java
public abstract class AbstractBehavior implements IBehavior {
    protected final BotContext context;
    protected boolean active = false;
    
    public AbstractBehavior(BotContext context) {
        this.context = context;
    }
    
    @Override
    public boolean isActive() {
        return active;
    }
    
    @Override
    public void activate() {
        this.active = true;
    }
    
    @Override
    public void deactivate() {
        this.active = false;
    }
}
```

#### 3.3 FarmingBehavior
```java
public class FarmingBehavior extends AbstractBehavior {
    private final MobFinder mobFinder;
    private final AttackAction attackAction;
    private final LootCollector lootCollector;
    
    @Override
    public boolean canExecute(BotContext context) {
        return context.getCurrentState() == BotState.FARMING &&
               mobFinder.findNearbyMobs(context) != null;
    }
    
    @Override
    public void execute(BotContext context) {
        List<L2Character> mobs = mobFinder.findNearbyMobs(context);
        if (mobs != null && !mobs.isEmpty()) {
            L2Character target = selectTarget(mobs);
            attackAction.execute(target);
        }
    }
}
```

### 4. ACTION COMPONENTS (Действия)

#### 4.1 IAction Interface
```java
public interface IAction {
    void execute() throws ActionException;
    void undo() throws ActionException;
    boolean canExecute();
    int getPriority();
    ActionType getType();
    long getExecutionTime();
}
```

#### 4.2 AbstractAction
```java
public abstract class AbstractAction implements IAction {
    protected final BotContext context;
    protected long startTime;
    
    public AbstractAction(BotContext context) {
        this.context = context;
    }
    
    @Override
    public void execute() throws ActionException {
        startTime = System.currentTimeMillis();
        doExecute();
    }
    
    protected abstract void doExecute() throws ActionException;
    
    @Override
    public long getExecutionTime() {
        return System.currentTimeMillis() - startTime;
    }
}
```

#### 4.3 MoveAction
```java
public class MoveAction extends AbstractAction {
    private final int targetX;
    private final int targetY;
    private final int targetZ;
    
    public MoveAction(BotContext context, int x, int y, int z) {
        super(context);
        this.targetX = x;
        this.targetY = y;
        this.targetZ = z;
    }
    
    @Override
    protected void doExecute() throws ActionException {
        FakePlayer bot = context.getBot();
        bot.moveToLocation(targetX, targetY, targetZ);
    }
    
    @Override
    public boolean canExecute() {
        return context.getBot().isAlive() && 
               !context.getBot().isMoving();
    }
}
```

### 5. MANAGER COMPONENTS (Менеджеры)

#### 5.1 BehaviorManager
```java
public class BehaviorManager {
    private final Map<BehaviorType, IBehavior> behaviors = new HashMap<>();
    private final BehaviorSelector selector;
    
    public void registerBehavior(IBehavior behavior);
    public void unregisterBehavior(BehaviorType type);
    public IBehavior getBehavior(BehaviorType type);
    public IBehavior selectBestBehavior(BotContext context);
    public Collection<IBehavior> getAllBehaviors();
}
```

#### 5.2 ActionManager
```java
public class ActionManager {
    private final Queue<IAction> actionQueue = new LinkedList<>();
    private final Map<ActionType, IAction> actions = new HashMap<>();
    
    public void addAction(IAction action);
    public void executeNext();
    public void clearQueue();
    public int getQueueSize();
}
```

#### 5.3 EventManager
```java
public class EventManager {
    private final Map<Class<?>, List<IEventListener<?>>> listeners = new HashMap<>();
    
    public <T extends BotEvent> void subscribe(Class<T> eventType, IEventListener<T> listener);
    public <T extends BotEvent> void unsubscribe(Class<T> eventType, IEventListener<T> listener);
    public <T extends BotEvent> void publish(T event);
    public void clear();
}
```

## ИНТЕГРАЦИЯ С L2J

### 1. Расширение FakePlayer
```java
public class EnhancedFakePlayer extends FakePlayer {
    private final BotContext context;
    private final AICore aiCore;
    private final BehaviorManager behaviorManager;
    private final ActionManager actionManager;
    
    public EnhancedFakePlayer(int objectId, String name, String title, 
                             int level, int exp, int sp, int curHp, int maxHp, 
                             int curMp, int maxMp, int curCp, int maxCp, 
                             int hairStyle, int hairColor, int face, int sex, 
                             int x, int y, int z, int heading, int karma, 
                             int pvpKills, int pkKills, int clanId, 
                             int race, int classId, int baseClass, 
                             long deleteTime, boolean haveForumAcc, 
                             int accessLevel, int onlineTime, boolean isOnline, 
                             int pledgeType, int pledgeRank, int titleColor, 
                             int apprentice, int sponsor, int clanPrivs, 
                             int wantsPeace, int isIn7sDungeon, 
                             int inJail, int jailTimer, int isNoble, 
                             int isHero, int isFakePlayer) {
        super(objectId, name, title, level, exp, sp, curHp, maxHp, 
              curMp, maxMp, curCp, maxCp, hairStyle, hairColor, face, sex, 
              x, y, z, heading, karma, pvpKills, pkKills, clanId, 
              race, classId, baseClass, deleteTime, haveForumAcc, 
              accessLevel, onlineTime, isOnline, pledgeType, pledgeRank, 
              titleColor, apprentice, sponsor, clanPrivs, wantsPeace, 
              isIn7sDungeon, inJail, jailTimer, isNoble, isHero, isFakePlayer);
        
        this.context = new BotContext(this);
        this.aiCore = new AICore();
        this.behaviorManager = new BehaviorManager();
        this.actionManager = new ActionManager();
        
        initializeBehaviors();
    }
    
    private void initializeBehaviors() {
        behaviorManager.registerBehavior(new FarmingBehavior(context));
        behaviorManager.registerBehavior(new QuestingBehavior(context));
        behaviorManager.registerBehavior(new PvPBehavior(context));
        behaviorManager.registerBehavior(new ClanBehavior(context));
    }
    
    @Override
    public void onAction(Player player, L2Object target, int dist, boolean interact) {
        // Обработка действий бота
        aiCore.process(context);
    }
}
```

### 2. Интеграция с GameServer
```java
public class BotSystemManager {
    private static BotSystemManager instance;
    private final BotManager botManager;
    private final EventManager eventManager;
    private final ConfigManager configManager;
    
    public static BotSystemManager getInstance() {
        if (instance == null) {
            instance = new BotSystemManager();
        }
        return instance;
    }
    
    private BotSystemManager() {
        this.botManager = new BotManager();
        this.eventManager = new EventManager();
        this.configManager = new ConfigManager();
        
        initializeSystem();
    }
    
    private void initializeSystem() {
        // Загрузка конфигурации
        configManager.loadConfig();
        
        // Создание ботов из базы данных
        loadBotsFromDatabase();
        
        // Запуск системы
        startSystem();
    }
    
    private void loadBotsFromDatabase() {
        // Загрузка ботов из базы данных
        List<BotData> botDataList = DatabaseManager.getInstance().getAllBots();
        for (BotData data : botDataList) {
            botManager.createBot(data.getId(), data.getType());
        }
    }
}
```

## СИСТЕМА СОБЫТИЙ

### 1. BotEvent Hierarchy
```java
public abstract class BotEvent {
    private final long timestamp;
    private final Object source;
    private final Map<String, Object> data;
    
    public BotEvent(Object source) {
        this.timestamp = System.currentTimeMillis();
        this.source = source;
        this.data = new HashMap<>();
    }
}

public class BotStateChangedEvent extends BotEvent {
    private final BotState oldState;
    private final BotState newState;
    
    public BotStateChangedEvent(Object source, BotState oldState, BotState newState) {
        super(source);
        this.oldState = oldState;
        this.newState = newState;
    }
}

public class BotActionCompletedEvent extends BotEvent {
    private final ActionType actionType;
    private final boolean success;
    
    public BotActionCompletedEvent(Object source, ActionType actionType, boolean success) {
        super(source);
        this.actionType = actionType;
        this.success = success;
    }
}
```

### 2. Event Listeners
```java
public class BotStateListener implements IEventListener<BotStateChangedEvent> {
    @Override
    public void onEvent(BotStateChangedEvent event) {
        // Обработка изменения состояния бота
        logStateChange(event.getOldState(), event.getNewState());
        updateBotUI(event);
    }
}

public class BotActionListener implements IEventListener<BotActionCompletedEvent> {
    @Override
    public void onEvent(BotActionCompletedEvent event) {
        // Обработка завершения действия
        if (event.isSuccess()) {
            logSuccessfulAction(event.getActionType());
        } else {
            logFailedAction(event.getActionType());
        }
    }
}
```

## КОНФИГУРАЦИЯ

### 1. Bot Configuration
```properties
# bot.properties
bot.maxCount=1000
bot.defaultType=FARMER
bot.autoCreate=true
bot.autoStart=true

# AI Configuration
ai.decisionInterval=100
ai.behaviorSwitchDelay=5000
ai.actionQueueSize=10

# Performance Configuration
performance.maxMemoryPerBot=50
performance.threadPoolSize=10
performance.asyncProcessing=true
```

### 2. Behavior Configuration
```properties
# behaviors.properties
behavior.farming.enabled=true
behavior.farming.priority=100
behavior.farming.mobSearchRadius=1000
behavior.farming.lootCollection=true

behavior.questing.enabled=true
behavior.questing.priority=80
behavior.questing.autoAccept=true
behavior.questing.autoComplete=true

behavior.pvp.enabled=false
behavior.pvp.priority=60
behavior.pvp.aggressiveMode=false

behavior.clan.enabled=true
behavior.clan.priority=40
behavior.clan.autoCreate=true
behavior.clan.autoInvite=true
```

## МОНИТОРИНГ И ЛОГИРОВАНИЕ

### 1. Logging Configuration
```xml
<!-- logback.xml -->
<configuration>
    <appender name="BOT_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/bot-system.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/bot-system.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <logger name="net.sf.l2j.gameserver.fakeplayer" level="DEBUG" additivity="false">
        <appender-ref ref="BOT_FILE"/>
    </logger>
</configuration>
```

### 2. Metrics Collection
```java
public class BotMetrics {
    private final AtomicInteger activeBots = new AtomicInteger(0);
    private final AtomicLong totalActions = new AtomicLong(0);
    private final AtomicLong successfulActions = new AtomicLong(0);
    private final AtomicLong failedActions = new AtomicLong(0);
    
    public void incrementActiveBots() {
        activeBots.incrementAndGet();
    }
    
    public void decrementActiveBots() {
        activeBots.decrementAndGet();
    }
    
    public void recordAction(boolean success) {
        totalActions.incrementAndGet();
        if (success) {
            successfulActions.incrementAndGet();
        } else {
            failedActions.incrementAndGet();
        }
    }
    
    public double getSuccessRate() {
        long total = totalActions.get();
        if (total == 0) return 0.0;
        return (double) successfulActions.get() / total;
    }
}
```

## ЗАКЛЮЧЕНИЕ

Эта архитектура обеспечивает:
- **Модульность**: Независимые компоненты
- **Масштабируемость**: Легко добавлять новые функции
- **Производительность**: Оптимизированная обработка
- **Надежность**: Обработка ошибок и восстановление
- **Гибкость**: Настраиваемое поведение
- **Мониторинг**: Полная видимость системы

Следующий шаг: [[GOAP-планировщик]] - детальное описание ИИ системы

